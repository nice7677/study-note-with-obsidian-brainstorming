
CPU 스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말함.
# CPU Scheduler

- 고수준 스케줄링 - Job
- 중간 수준 스케줄링 - Buffer
- 저수준 스케줄링 - 단기 스케줄링

### 고수준 스케줄링

고수준 스케줄링은 시스템 내의 전체 작업 수를 조절 한다. 작업은 OS에서 다루는 일의 가장 큰 단위로, 1개 또는 여러개의 프로세스로 이루어진다.

전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정한다.

### 저수준 스케줄링

저수준 스케줄링은 고수준과 반대로 가장 작은 단위의 스케줄링이다.

저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정함.

저수준 스케줄링은 아주 짧은 시간에 일어나기에 단기 스케줄링이라고 부른다.

CPU 스케줄러는 특별한 명시가 없는 한 저수준 스케줄러를 의미한다.

### 중간 수준 스케줄링

고수준과 저수준 사이의 Buffer 역할을 하는 스케줄링이다.

시스템의 부하를 조절하려면 중간 수준 스케줄링을 고려해야 한다.

중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.

일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동되도록 지원함.

### 스케줄링의 목적

- 공평성
- 효율성
- 안정성
- 확장성
- 반응 시간 보장
- 무한 연기 방지

# 스케줄링 시 고려 사항

## 선점형 스케줄링과 비선점형 스케줄링

- 선점 - 빼앗을 수 있음
- 비선점 - 빼앗을 수 없음

선점형 스케줄링은 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링이다.

비선점형 스케줄링은 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식이다.

선점형 스케줄링 방식의 대표적인 예는 인터럽트 처리.

인터럽트 처리가 완료되면 원래 작업으로 돌아간다.

선점형은 컨텍스트 스위칭과같은 부가적인 작업으로 인해 낭비가 생김.

대부분 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.

비선점형 스케줄링은 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행된다. 스케줄러의 작업량이 적고 컨텍스트 스위칭에 의한 낭비가 적다.

## 프로세스 우선순위

프로세스는 커널 프로세스와 일반 프로세스로 나뉜다.

CPU 스케줄러는 각 프로세스에 우선순위를 부여하는데 커널 프로세스의 우선순위가 일반 프로세스보다 높다.

우선순위가 높다는 것은 더 빨리 자주 실행된다는 의미. 준비 상태의 커널 프로세스와 일반 프로세스가 하나씩 있다면 커널 프로세스의 우선순위가 더 높기 때문에 커널 프로세스가 먼저 실행되며 작업이 끝날 때가지 계속 CPU를 사용함.

또한 같은 커널 프로세스라 하더라도 더 중요한 커널 프로세스는 우선순위가 높고 덜 중요한 프로세스는 우선순위가 낮다.

일반 프로세스도 중요도가 각각 다르기 때문에 우선순위가 서로 다르다.

우선순위를 조절할 때는 해당 프로세스뿐 아니라 다른 프로세스의 실행 속도에 영향을 미친다는 점을 주의 해야한다.

시스템에는 다양한 우선순위의 프로세스가 공존하며 우선순위가 높은 프로세스가 CPU를 먼저 더 오래 차지한다.

## CPU 집중 프로세스와 입출력 집중 프로세스

CPU 집중 프로세스, 입출력 집중 프로세스

![A virtual machine scheduler based on CPU and I/O-bound features for  energy-aware in high performance computing clouds - ScienceDirect](https://ars.els-cdn.com/content/image/1-s2.0-S0045790616302270-gr1.jpg)
위에 보는 것 처럼 IO bound 는 IO에 시간이 오래 걸리기에 이때 CPU bound로 넘어가 작업을할수있음.

CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.

스케줄링할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율이 향상 된다.

입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기라고 함.

# 다중 큐

## 준비 상태의 다중 큐

PCB에는 중요도가 표시된다.

CPU 스케줄러는 모든 PCB를 뒤져 우선순위가 가장 높은 프로세스에 CPU를 할당한다. 하지만 매번 검색하는 것은 상당히 번거롭다.

그래서 PCB를 우선순위로 여러개의 큐를 만들어 놓고 사용하면 편리하다.

이 방식에는 **고정 우선순위 방식**, **변동 우선순위 방식**이 있다.

고정 우선순위 방식은 말 그대로 생성과 동시에 고정되는 우선순위이고 변동 우선순위 방식은 우선순위가 변경되는 방식이다. 변동 우선순위 방식이 더 효율을 높일 수 있다.

## 대기 상태의 다중 큐

대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓는다.

같은 장치의 입출력을 기다리는 프로세스의 PCB는 동일한 입출력 큐에 모여 있다.

예를 들면 하드디스크의 입출력을 기다리는 PCB는 모두 HDD 큐에 삽입된다. 하드디스크에서 완료 인터럽트가 도착하면 HDD 큐에 있는 프로세스 제어 블록을 검색하여 이 프로세스 제어 블록의 상태를 준비 상태로 바꾸고 HDD 큐에서 제거한 후 준비 큐로 이동한다.

준비 상태의 큐와 대기 상태의 큐 간에는 차이가 있음.

준비 큐는 한번에 하나씩 CPU를 할당하는데 대기 큐는 여러개의 PCB를 동시에 꺼내 준비 상태로 옮긴다. 그리고 한꺼번에 처리 된다. 이렇게 한꺼번에 처리하기 위해 인터럽트 벡터라는 자료구조를 사용한다.

대기 상태의 다중 큐에 있는 PCB는 큐에 삽입된 순서대로 처리되지만 일부는 나중에 들어온 프로세스 제어 블록이 먼저 준비 상태로 옮겨 가기도 한다. 입출력장치는 CPU나 메모리보다 느리기 때문에 작업 속도를 높이기 위해 작업 순서를 뒤바꾸는 경우가 있는데 이 때는 나중에 요청된 작업이 먼저 처리되기도 한다.

# 인터럽트 처리

## 인터럽트의 개념

인터럽트 처리는 입출력뿐 아니라 시스템 보호에 매우 중요한 역할을 한다.

Event driven과 같은 방식을 사용하여  입출력을 요청하고 입출력이 완료되면 이벤트를 발생 시켜 사실을 알리는데 이를 인터럽트라한다.

만약에 프로그램이 무한 루프를 돌고있을때 컨트롤 C를 눌러 끄는 것이 인터럽트이다.

어떤 프로세스가 실행 도중 다른 프로세스가 사용 중인 메모리 영역을 침범하면 CPU에 있는 메모리 관련 레지스터가 인터럽트를 발생시켜 해당 프로세스를 강제 종료한다.

# 동기적 인터럽트와 비동기적 인터럽트

인터럽트는 프로세스가 실행 중인 명령어로 인해 발생하는 동기적 인터럽트와 실행 중인 명령어와 무관하게 발생하는 비동기적 인터럽트로 나눌 수 있음.

동기적 인터럽트는 사용자 인터럽트라고도 하며 다음과 같은 상황에서 발생함.
- 프로그램의 문제 때문에 발생하는 인터럽트
- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
- 입출력장치 같은 주변장치의 조작에 의한 인터럽트
- 산술 연산 중 발생하는 인터럽트

비동기적 인터럽트는 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어 오류로 발생하는 인터럽트다.

# 인터럽트 처리 과정

인터럽트는 해당 인터럽트가 발생하면 어떤 일을 할지도 정의되어 있다. 즉, 인터럽트 번호화 그 번호에 붙어 있는 함수의 쌍으로 이루어져있다. 시스템에는 많은 인터럽트가 있고 고유번호가 있음. 이를 윈도우에서는 IRQ라고한다. 시스템에 인터럽트가 발생하면 IRQ로 인터럽트를 식별한다.

인터럽트 처리 과정
1) 인터럽트 발생시 현재 실행 중인 프로세스는 일시 정지 상태가 되고 재시작하기 위해 현재 프로세스 관련 정보를 임시로 저장
2) 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정함. 이때 여러 개의 인터럽트가 동시에 발생했다면 우선순위를 고려하여 중요한 인터럽트부터 처리하도록 순서를 결정
3) 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행. 인터럽트 핸들러는 인터럽트 처리를 위해 미리 정의된 함수이고 인터럽트 벡터는 인터럽트와 인터럽트 핸들러를 일대일로 연결한 자료구조다. 인터럽트 처리를 위해 함수를 정의하여 인터럽터 벡터에 등록해 놓으면 해당 인터럽트 발생 시 함수가 실행되어 처리한다.
4) 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료됨. 발생한 인터럽트가 입출력 완료라면 일시정지된 프로세스가 다시 실행되고, 다른 프로세스의 메모리 영역 침범이나 오류라면 종료된다.
## 인터럽트와 이중 모드

프로세스는 커널 프로세스, 사용자 프로세스로 나뉜다.

운영체제와 관련된 커널 프로세스가 실행되는 상태를 커널 모드, 사용자 프로세스가 실행되는 상태를 사용자 모드라고 함. Kernel mode, User mode

User Process가 하드디스크 입출력, 프로세스 생성과 같은 커널의 기능을 사용하려면 시스템 호출을 이용하여 커널 프로세스에 작업을 요청해야 함.

사용자 프로세스는 시스템 호출을 요청한 후 대시 상태로 전환되고 커널 프로세스는 요청 받은 작업을 처리함.

즉 User mode에서 Kernel mode로 전환되는데 이와 같이 OS가 두 모드를 전환하며 일 처리를 하는 것을 이중 모드라고 함. Dual mode

Dual mode는 Os가 자원을 보호하기 위해 사용하는 기법임.

User process가 system resource에 직접 접근하면 문제가 발생할수 있기에 커널은 시스템 호출을 통해서만 자원에 접근하도록 제한한다. 즉 사용자 프로세스가 커널 모드에서 실행되지 못하게 함.

그렇기에 사용자는 API를 통해 시스템 자원에 접근할 수 있음.

사용자가 커널 모드로 진입하는 경우는 두가지임.

1) 시스템 호출을 사용한 경우
2) 인터럽트를 발생시킨 경우
시스템 호출에 의해 커널 모드로 진입하는 것은 사용자 프로세스가 원해서 진입하는 것이기 때문에 자발적이지만 인터럽트에 의해 커널 모드로 진입하는 것은 비자발적임. 어떤 프로세스가 인터럽트를 발생시켰다는 것은 잘못된 명령을 수행하여 동기적 인터럽트가 발생한 것이기에 프로세스가 강제 종료됨. 

사용자 프로세스가 자발적으로 커널 모드에 진입할수있는 유일한 수단은 시스템 호출뿐.
