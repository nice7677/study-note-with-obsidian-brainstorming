
CPU 스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말함.
# CPU Scheduler

- 고수준 스케줄링 - Job
- 중간 수준 스케줄링 - Buffer
- 저수준 스케줄링 - 단기 스케줄링

### 고수준 스케줄링

고수준 스케줄링은 시스템 내의 전체 작업 수를 조절 한다. 작업은 OS에서 다루는 일의 가장 큰 단위로, 1개 또는 여러개의 프로세스로 이루어진다.

전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정한다.

### 저수준 스케줄링

저수준 스케줄링은 고수준과 반대로 가장 작은 단위의 스케줄링이다.

저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정함.

저수준 스케줄링은 아주 짧은 시간에 일어나기에 단기 스케줄링이라고 부른다.

CPU 스케줄러는 특별한 명시가 없는 한 저수준 스케줄러를 의미한다.

### 중간 수준 스케줄링

고수준과 저수준 사이의 Buffer 역할을 하는 스케줄링이다.

시스템의 부하를 조절하려면 중간 수준 스케줄링을 고려해야 한다.

중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.

일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동되도록 지원함.

### 스케줄링의 목적

- 공평성
- 효율성
- 안정성
- 확장성
- 반응 시간 보장
- 무한 연기 방지

# 스케줄링 시 고려 사항

## 선점형 스케줄링과 비선점형 스케줄링

- 선점 - 빼앗을 수 있음
- 비선점 - 빼앗을 수 없음

선점형 스케줄링은 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링이다.

비선점형 스케줄링은 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식이다.

선점형 스케줄링 방식의 대표적인 예는 인터럽트 처리.

인터럽트 처리가 완료되면 원래 작업으로 돌아간다.

선점형은 컨텍스트 스위칭과같은 부가적인 작업으로 인해 낭비가 생김.

대부분 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.

비선점형 스케줄링은 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행된다. 스케줄러의 작업량이 적고 컨텍스트 스위칭에 의한 낭비가 적다.

## 프로세스 우선순위

프로세스는 커널 프로세스와 일반 프로세스로 나뉜다.

CPU 스케줄러는 각 프로세스에 우선순위를 부여하는데 커널 프로세스의 우선순위가 일반 프로세스보다 높다.

우선순위가 높다는 것은 더 빨리 자주 실행된다는 의미. 준비 상태의 커널 프로세스와 일반 프로세스가 하나씩 있다면 커널 프로세스의 우선순위가 더 높기 때문에 커널 프로세스가 먼저 실행되며 작업이 끝날 때가지 계속 CPU를 사용함.

또한 같은 커널 프로세스라 하더라도 더 중요한 커널 프로세스는 우선순위가 높고 덜 중요한 프로세스는 우선순위가 낮다.

일반 프로세스도 중요도가 각각 다르기 때문에 우선순위가 서로 다르다.

우선순위를 조절할 때는 해당 프로세스뿐 아니라 다른 프로세스의 실행 속도에 영향을 미친다는 점을 주의 해야한다.

시스템에는 다양한 우선순위의 프로세스가 공존하며 우선순위가 높은 프로세스가 CPU를 먼저 더 오래 차지한다.

## CPU 집중 프로세스와 입출력 집중 프로세스

CPU 집중 프로세스, 입출력 집중 프로세스

![A virtual machine scheduler based on CPU and I/O-bound features for  energy-aware in high performance computing clouds - ScienceDirect](https://ars.els-cdn.com/content/image/1-s2.0-S0045790616302270-gr1.jpg)
위에 보는 것 처럼 IO bound 는 IO에 시간이 오래 걸리기에 이때 CPU bound로 넘어가 작업을할수있음.

CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.

스케줄링할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율이 향상 된다.

입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기라고 함.

# 다중 큐

## 준비 상태의 다중 큐

PCB에는 중요도가 표시된다.

CPU 스케줄러는 모든 PCB를 뒤져 우선순위가 가장 높은 프로세스에 CPU를 할당한다. 하지만 매번 검색하는 것은 상당히 번거롭다.

그래서 PCB를 우선순위로 여러개의 큐를 만들어 놓고 사용하면 편리하다.

이 방식에는 **고정 우선순위 방식**, **변동 우선순위 방식**이 있다.

고정 우선순위 방식은 말 그대로 생성과 동시에 고정되는 우선순위이고 변동 우선순위 방식은 우선순위가 변경되는 방식이다. 변동 우선순위 방식이 더 효율을 높일 수 있다.

## 대기 상태의 다중 큐

대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓는다.

같은 장치의 입출력을 기다리는 프로세스의 PCB는 동일한 입출력 큐에 모여 있다.

예를 들면 하드디스크의 입출력을 기다리는 PCB는 모두 HDD 큐에 삽입된다. 하드디스크에서 완료 인터럽트가 도착하면 HDD 큐에 있는 프로세스 제어 블록을 검색하여 이 프로세스 제어 블록의 상태를 준비 상태로 바꾸고 HDD 큐에서 제거한 후 준비 큐로 이동한다.

준비 상태의 큐와 대기 상태의 큐 간에는 차이가 있음.

준비 큐는 한번에 하나씩 CPU를 할당하는데 대기 큐는 여러개의 PCB를 동시에 꺼내 준비 상태로 옮긴다. 그리고 한꺼번에 처리 된다. 이렇게 한꺼번에 처리하기 위해 인터럽트 벡터라는 자료구조를 사용한다.

대기 상태의 다중 큐에 있는 PCB는 큐에 삽입된 순서대로 처리되지만 일부는 나중에 들어온 프로세스 제어 블록이 먼저 준비 상태로 옮겨 가기도 한다. 입출력장치는 CPU나 메모리보다 느리기 때문에 작업 속도를 높이기 위해 작업 순서를 뒤바꾸는 경우가 있는데 이 때는 나중에 요청된 작업이 먼저 처리되기도 한다.