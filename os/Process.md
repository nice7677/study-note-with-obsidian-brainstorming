# PCB
프로세스 제어 블록

- 프로세스 구분자 - ID 가 필요, PID
- 메모리 관련 정보 - 메모리가 어디 저장되어 있느지 알아야함. PCB에 메모리 위치 정보가 담겨있다. 또한 메모리 보호를 위해 경계 레지스터와 한계 레지스터도 포함되어 있다.
- 각종 중간값 - 프로세스 제어 블록에 프로세스가 사용했던 중간값이 저장되는데 이는 현재 어떤 일을 진행중이였는지 표시하는 것. 시분할 시스템에서는 여러 브로세스가 번갈아 가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPUfㅡㄹ 넘겨준다.

프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터와 각종 레지스터 같은 중간값을 관리해야 한다.

이러한 정보를 보관하는 데이터 구조가 프로세스 제어 블록이다 **PCB**

프로그램이 프로세서가 되려면 메모리에 올라오는 것과 동시에 PCB가 생성 되어야 한다.

PCB는 운영체제가 해당 프로세스를 실행하기 위해 관리하는 데이터 구조이므로 운영체제 영역에 만들어 진다.

프로세스가 종료되면 프로세스는 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.

# 프로세스의 다섯가지 상태

- 생성상태 - 저장장치에 저장된 프로그램이 메모리에 올라와 실행되어 프로세스가 되는 상태로 커널 영역에 PCB가 생성된다. 생성 후 준비 상태로 이동한다.
- 준비상태 - 실행을 기다리는 모든 ㅡ로세스가 준비 큐에서 자기 차례를 기다리는 상태. 실행될 프로세스를 CPU 스케줄러가 선택한다.
- 실행상태 - 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태. 작업을 마치면 완료 상태로 가고 작업을 끝내지 못하면 준비 상태로 되돌아간다.
- 대기상태 - 실행 상태에 있는 ㅡ로세스가 입출력을 요청하면 입출력이 완료 될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 이동한다.
- 완료상태 - 프로세스가 종료된 상태. 사용하던 모든 자원은 반납되고 메모리에서 지워지고 PCB는 폐기 된다.

# 휴식 상태와 보류 상태

- 휴식 상태 - 프로세스가 작업을 일시적으로 쉬고 있는 상태. 종료된 것처럼 보이지만 실행을 잠시 멈춘 것이다. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있다. (PCB가 폐기되지 않았기 때문인가?)
- 보류 상태 - 보류는 어떤 상황에 처해 메모리에서 잠시 쫓겨난 상태이다. 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다. 스왑영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳이다. 보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨[]()진 보류 준비 상태로 구분되며 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. 또한 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨 진다.
# 문맥 교환

# Context switching

P1과 P2가 있을때 자신에게 주어진 시간을 다 사용하여 타임아웃이 되면 P1의 PCB에  현재까지의 작업 결과를 저장하고 P1은 준비 상태로 쫓겨난다. 준비 상태에 있던 P2가 실행 상태로 가면 CPU의 레지스터가 P2의 PCB를 불러와 다음 작업을 하게 된다.

컨텍스트 스위칭은 자기에게 주어진 시간이 다하거나, 인터럽트가 걸렸을때 발생한다.

예로 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 하면 이는 경계 레지스터의 범위를 벗어나는 것으로 인터럽트가 발생하고 실행 중인 PCB를 저장하고 언터럽트 관리 프로세스를 실행 상태로 만든다. 인터럽트 관리 프로세스는 메모리 범위를 넘어선 프로세스를 강제로 종료하고 인터럽트 처리를 마치는데 이와 같이 인터럽트 처리를 할 때도 컨텍스트 스위칭이 일어난다.

# 프로세스의 연산

## 프로세의 구조

- 코드 영역
- 데이터 영역 - 일반 데이터 영역과 힙 영역으로 나뉜다.
- 스택 영역

프로그램을 실행하면 이 프로그램은 코드 영역에 탑재되고 작업 중인 데이터는 데이터 영역에 탑재 된다. 프로그램이 작동하기 위해 사용하는 각종 부가 데이터는 스택 영역에서 관리한다.

## 프로세스의 생성과 복사

- fork() - 프로세스 생성을 위해 부모 프로세스에 있는 데이터들을 새로운 프로세스 메모리 영역에 올린다.
- exec() - 프로세스 생성을 하는 것이 아니라 exec로 호출된 프로세스는 새로운 프로세스에 의해 덮어 씌워진다.

### fork

fork()를 호출 하면 프로세스 제어블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어 진다. 단 PCB의 내용중 일부가 변경되는데. 
- PID
- 메모리 관련 정보
- PPID, CPID가 바뀐다.
자식프로세스가 없는 경우에 CPID는 -1 이다.

장점 
- 프로세스의 생성 속도가 빠르다
	- 기존 메모리를 복사하기 때문에 자식 프로세서의 생성 속도가 빠르다.
- 추가 작업 없이 자원을 상속할 수 있다
	- 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다.
	- 부모 프로세서와 자식 프로세스가 구분자와 부모 프로세스 구분자로 연결되어 있기 때문에 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리 할 수 있다. 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리된다.

### 프로세스의 전환

#### exec
exec는 기존 프로세스를 새로운 프로세스로 전환하는 함수다. 프로세스는 그냥 둔 채 내용만 바꾸는 것이다. exec를 실행하게되면 현재의 프로세스는 완전히 다른 프로세스로 전환된다.
목적은 프로세스를 재활용하기 위함이다. 프로세스를 완전히 새로 만드는 것보다 작업이 수월하다.

exec을 실행하면 코드 영역에 있는 기존 내용이 지워지고 새로운 코드로 바뀐다. 또한 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. PCB내용중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋 된다.

wait 문은 자식 프로세스와 동기화하기 위한 코드다. 자식 프로세스가 끝날 때까지 부모 프로세스가 기다리는 것이다.

### 고아 프로세스와 좀비 프로세스
부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 하는데 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안되는 경우 자식 프로세스가 종료되지 않거나 종료되었는데도 사용하던 자원이 그대로 남게 된다.

자식 프로세스가 종료되기 전에 부모 프로세스가 먼저 종료되면 자식 프로세스는 **고아 프로세스**가 된다. 고아 프로세스는 부모 프로세스가 먼저 종료되어 돌아갈 곳이 없는 프로세스를 가르킨다.

**좀비 프로세스**는 자식 프로세스가 종료되었는데도 부모 프로세스가 뒤처리를 하지 않을 때 발생한다.

고아 프로세스나 좀비 프로세스가 많아지면 자원이 낭비되기 때문에 효율적인 운영에 방해가 된다. 따라서 운영체제는 주기적으로 반환하지 못한 자원을 회수해야 한다.