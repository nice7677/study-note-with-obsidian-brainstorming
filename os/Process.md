# PCB
프로세스 제어 블록

- 프로세스 구분자 - ID 가 필요, PID
- 메모리 관련 정보 - 메모리가 어디 저장되어 있느지 알아야함. PCB에 메모리 위치 정보가 담겨있다. 또한 메모리 보호를 위해 경계 레지스터와 한계 레지스터도 포함되어 있다.
- 각종 중간값 - 프로세스 제어 블록에 프로세스가 사용했던 중간값이 저장되는데 이는 현재 어떤 일을 진행중이였는지 표시하는 것. 시분할 시스템에서는 여러 브로세스가 번갈아 가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPUfㅡㄹ 넘겨준다.

프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터와 각종 레지스터 같은 중간값을 관리해야 한다.

이러한 정보를 보관하는 데이터 구조가 프로세스 제어 블록이다 **PCB**

프로그램이 프로세서가 되려면 메모리에 올라오는 것과 동시에 PCB가 생성 되어야 한다.

PCB는 운영체제가 해당 프로세스를 실행하기 위해 관리하는 데이터 구조이므로 운영체제 영역에 만들어 진다.

프로세스가 종료되면 프로세스는 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.

# 프로세스의 다섯가지 상태

- 생성상태 - 저장장치에 저장된 프로그램이 메모리에 올라와 실행되어 프로세스가 되는 상태로 커널 영역에 PCB가 생성된다. 생성 후 준비 상태로 이동한다.
- 준비상태 - 실행을 기다리는 모든 ㅡ로세스가 준비 큐에서 자기 차례를 기다리는 상태. 실행될 프로세스를 CPU 스케줄러가 선택한다.
- 실행상태 - 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태. 작업을 마치면 완료 상태로 가고 작업을 끝내지 못하면 준비 상태로 되돌아간다.
- 대기상태 - 실행 상태에 있는 ㅡ로세스가 입출력을 요청하면 입출력이 완료 될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 이동한다.
- 완료상태 - 프로세스가 종료된 상태. 사용하던 모든 자원은 반납되고 메모리에서 지워지고 PCB는 폐기 된다.

# 휴식 상태와 보류 상태

- 휴식 상태 - 프로세스가 작업을 일시적으로 쉬고 있는 상태. 종료된 것처럼 보이지만 실행을 잠시 멈춘 것이다. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있다. (PCB가 폐기되지 않았기 때문인가?)
- 보류 상태 - 보류는 어떤 상황에 처해 메모리에서 잠시 쫓겨난 상태이다. 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다. 스왑영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳이다. 보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분되며 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. 또한 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨 진다.