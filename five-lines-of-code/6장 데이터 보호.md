# 6.1.1 규칙: getter와 setter를 사용하지 말것

흔히 알고 있는 내용.

내용중 getter가 존재하는 순간 캡슐화를 해제하고 불변속성을 전역적으로 만들게 된다.

저 내용이 일급컬렉션에 존재하는 값을 불변으로 한번더 선언하고 get으로 내보내는 이유일까보다.

# 6.2.1 규칙: 공통 접사를 사용하지 말 것

흔히 알고 있는 내용.

단일 책임 원칙을 지키라는 것. 한가지 일만 하자.

데이터 보호를 다루는 장 답게 private으로 메소드를 숨기거나 변수자체를 잘 숨겨 캡슐화를 유지하자.

# 6.2.2 규칙 적용하기

쉽다. 위에서 언급한 SRP를 적용하자.

만약 다음과 같은 메서드나 변수가 존재할때
- playerx
- playery
- drawPlayer
공통적으로 보이는 player를 클래스로 옴기고 하위에 x,y,draw를 제어하는 기능을 구현하자.

# 6.2.3 리팩터링 패턴: 데이터 캡슐화

6장 데이터 보호는 빠질게 없다. 전부 숙지하면 좋은 내용뿐이다.

### 설명

변수와 메서드를 캡슐화해서 접근할 수 있는 지점을 제한하고 구조를 명확하게 만들 수 있다.

메서드를 캡슐화하면 이름을 단순하게 만들고 응집력을 더 명확하게 하는데 도움이 된다.

이것은 곧 더 좋은 클래스로 이어지게 된다.

클래스가 작고 많을 수록 유익하다.

가장 중요한 이점은 변수를 캡슐화하는데서 얻을 수 있다.

변수를 이곳저곳에서 접근할 수록 유지보수가 어려워진다.

불변 클래스의 경우 내부 코드만 확인하면된다. 일급 객체 짱 좋은듯.

# 6.4 순서에 존재하는 불변속성 제거하기

# 6.4.1 리팩터링 패턴: 순서 강제화

### 설명

객체지향 언어에서는 생성자가 항상 객체의 메서드보다 먼저 호출되어야 한다.

생성자를 사용해 일부 코드가 실행되게 하면 클래스의 인스턴스 코드가 실행되었다는 증거다.

생성자를 성공적으로 실행하지 않고는 인스턴스를 얻을 수 없기 때문임.

