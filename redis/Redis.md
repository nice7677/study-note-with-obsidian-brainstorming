
# Remote dictionary server

줄여서 Redis

고성능 키-값 유형의 인메모리 NoSQL.

[[NoSQL]]에서 설명한 유형중 키-값에 해당하며

키-값은 가장 단순하고 빠르다.

키는 RDB에서 PK에 해당한다.

키 자체도 유의미한 데이터임.

다른 유형보다 수평적 확장이 쉽다.

빠른 데이터 액세스와 처리 속도를 보장해 준다.

RDBMS와는 다르게 인메모리이기 때문에 모든 데이터가 메모리에서 관리됨.

디스크 접근이 필요없기 때문에 데이터 처리 성능이 굉장히 빠르다.

하지만 싱글스레드에서 동작하는 경우 오래 걸리는 작업을 실행한 경우에는 그 쿼리가 완료되야 다음 쿼리가 실행되기때문에 주의해 사용해야함.

고가용성을 제공함.

센티널은 장애 상황을 탐지해 자동으로 페일오버 시킴. 
? 센티널? 공부
? 페일오버? 공부

레디스는 쉬운 수평적 확장이 가능하다.

### 데이터 저장소로서의 레디스

메모리에 있는 데이터는 영구 저장되지 않는다 하지만 AOF, RDB 형식으로 디스크에 주기적으로 저장할 수 있다. 그렇기에 장애가 발생해 데이터가 유실되도 백업 파일을 사용해 복구할수있음.

### 메시지 브로커로서의 레디스

레디스를 저장소로만 사용하는게아니라 서비스 간 메시지를 전달하는 메시지 브로커로 사용 할 수 있음.

그건 레디스의 pub/sub 기능 덕이다.

굉장히 빠르게 동작하고 간단하게 사용 가능하다.

pub/sub은 1회성이며 1개의 채널에 데이터를 던지면 이 채널을 듣고 있는 모든 소비자는 데이터를 빠르게 가져갈 수 있음.

레디스의 list 자료구조는 메시징 큐로 사용하기 알맞다.

push/pop을 할 수 있음.

데이터가 없을때 대기하다 새로운 데이터가 오면 읽어 갈 수 있는 블로킹 기능을 사용할 수 도있음.

stream자료 구조를 사용하면 레디스를 완벽히 스트림 플랫폼으로 사용할수있음.

stream 자료 구조는 카프카를 본딴것임.

그렇기에 컨슈머와 퍼블리셔도 존재함. 분산처리도 가능함.

# 레디스에서 키를 관리하는 법

## 키의 자동 생성과 삭제

stream, set, sorted set, hash 와 같이 하나의 키가 여러개의 아이템을 가지고 있는 자료 구조에서는 명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제 된다. 키의 생성과 삭제는 세 가지 공통적인 규칙을 따른다.

1) 키가 존재하지 않을 때 아이템을 넣으면 아이템을 삽입하기 전에 빈 자료 구조를 생성한다.
2) 모든 아이템을 삭제하면 키도 자동으로 삭제된다. (단 stream은 예외)
3) 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료 구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 에러를 반환하는 대신 키가 있으나 아이템이 없는 것처럼 동작 한다

## 키와 관련된 커맨드

- EXISTS - 키가 존재하는지 확인. 존재하면 1 그렇지 않으면 0을 반환
- KEYS - 레디스에 저장된 모든 키를 조회. 매칭되는 패턴에 해당하는 모든 키의 list를 반환. 패턴은 글롭 패턴 스타일로 동작한다.
	- KEYS는 위험한 커맨드이다. 레디스에 많은 데이터가 있을때 이 모든 데이터를 조회하기에 싱글 스레드로 동작하는 레디스는 실행 시간이 오래 걸릴 수 있다.
- SCAN - KEYS를 대체해 키를 조회할 때 사용. SCAN은 KEYS와 다르게 특정 범위의 키만 조회 하기에 비교적 안전하게 사용할수있다.
	- 하지만 SCAN에서도 count 옵션을 너무 크게 설정하면 반환되는 값이 많아져 출력에 오랜 시간이 걸린다면 서비스에 영향을 줄 수있다.
	- 비슷한 커맨드로는
		- SSCAN
		- HSCAN
		- ZSCAN
	- 다음과 같은 커맨드가 존재하며 set, hash, sorted set에 조회하기 위해 사용되는 것을들 대체해 서버에 최대한 영향을 끼치지 않고 반복해서 호출할 수 있도록 사용할 수 있다.
- SORT - list, set, sorted set 에서만 사용. 키 내부의 아이템을 정렬해 반환, ASC/DESC 옵션을 사용해 정렬 순서를 변경 가능, 문자열일 경우 ALPHA 옵션을 사용하여 사전 순으로 정렬 조회 가능
- RENAME / RENAMEENX - 모두 키의 이름을 변경 한다. 하지만 RENAMENX는 오직 변경할 키가 존재하지 않을 때만 동작
- COPY - source에 지정된 키를 destination 키에 복사. Destination에 지정한 키가 이미 있는 경우 에러가 반환되는데 REPLACE 옵션을 사용하면 Destination 키를 삭제 한 뒤 값을 복사하기 때문에 에러가 발생하지 않는다.
- TYPE - 지정한 키의 자료구조 타입을 반환한다.
- OBJECT - 키에 대한 상세 정보를 반환

## 키의 삭제

- FLUSHALL - 레디스에 저장된 모든 키를 삭제. SYNC한 방식으로 동작하기에 모든 데이터가 삭제된 경우에만 OK를 반환한다. 실행되는 도중에는 다른 응답 처리를 할 수 없다. ASYNC 옵션을 사용하면 flush는 백그라운드로 실행되고 커맨드가 수행됐을 때 존재했던 키만 삭제해서 flush되는 중 새로운 생성된 키는 삭제되지 않는다.
- DEL - 키와 키에 저장된 모든 아이템을 삭제. 기본적으로 동기적으로 작동한다.
- UNLINK - DEL과 비슷하게 키와 데이터를 삭제하는 커맨드. 하지만 백그라운드에서 다른 스레드에 의해 처리되며 우선 키와 연결된 데이터의 연결을 끊는다.

## 키의 만료 시간

- EXPIRE - 키가 만료될 시간을 초 단위로 정의 할 수 있음.
	- 옵션은 다음과 같다
		- NX - 해당 키에 만료 시간이 정의돼 있지 않은 경우에 수행
		- XX - 해당 키에 만료 시간이 정의돼 있을 때만 실행
		- GT - 현재 키가 가지고 있는 만료 시간 보다 새로 입력한 초가 더 클때만 실행
		- LT - 현재 키가 가지고 있는 만료 시간 보다 새로 입력한 초가 더 작을때만 실행
- EXPIREAT - 키가 특정 유닉스 타임스탬프에 만료될 수 있도록 키의 만료 시간을 직접 지정. 옵션은 EXPIRE와 같음
- EXPIRETIME - 키가 삭제되는 유닉스 타임스탬프를 초 단위로 반환. 키가 존재하지만 만료 시간이 설정돼 있지 않은 경우에는 -1, 키가 없을때에는 -2를 반환
- TTL - 키가 몇 초 뒤에 만료되는지 반환한다. 키가 존재하지만 만료 시간이 설정돼 있지 않은 경우에는 -1을, 키가 없을 때에는 -2를 반환한다.

PEXPIRE, PEXPIREAT, PEXPIRETIME, PTTL은 밀리초 단위로 계산된다는 점만 다르며 위와 동일하다.
