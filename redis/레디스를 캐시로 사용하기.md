어떤 상황에서 캐시를 사용해야 하는지 레디스를 캐시로 잘 사용하는 방법과 주의해야 할점까지 짚어보고 캐시와 비슷하면서도 다른 세션 스토어에 대해 함께 보자.

# 레디스와 캐시

## 캐시란?

데이ㅓ의 원본보다 더 빠르고 효율적으로 엑세스할 수 있는 임시 데이터 저장소를 의미한다. 사용자가 동일한 정보를 반복적으로 액세스할 때 원본이 아니라 캐시에서 데이터를 가지고 옴으로써 리소스를 줄인다.

캐시를 도입했을 때 성능을 효과적으로 개선할 수 있다.
- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야한다.
- 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
- 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
- 캐시에 저장된 데이터는 자주 검색되는 데이터다.
위의 조건들을 만족시키는 이상적인 캐시는 애플리케이션이 직면하게 되는 많은 문제점을 해결할 수 있다.

대기 시간 단축, 원본 데이터 저장소에 대한 커넥션 줄이기, CPU와 메모리 등의 리소스를 줄일수있으며 같은 값을 도출하기 위해 계속 같은 계산을 할 필요가 없으므로 리소스를 최적화시킬 수 있게 된다.

## 캐시로서의 레디스

레디스는 사용이 간단하다. 단순하게 키-값 형태로 저장되므로 데이터를 저장하고 반환하는 것이 굉장히 간단하며 자체적으로 다양한 자료 구조를 제공하기 때문에 애플리케이션에서 사용하던 list, hash 등의 자료 구조를 변환하는 과정 없이 레디스에 바로 저장할 수 있다.

또한 레디스는 인메모리 데이터 저장소이기에 데이터를 검색하고 반환하는 것이 상당히 빠르다는 특징을 가진다.

레디스는 자체적으로 고가용성 기능을 가지고 있는 솔루션이라는 점도 큰 장점이다. 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시키기 때문에 운영자 개입 없이 캐시는 정상으로 유지될 수 있어 가용성이 높아진다.

레디스의 클러스터를 사용하면 캐시의 스케일 아웃또한 쉽게 처리할 수 있어 서비스의 규모에 따라 캐시 자체의 규모도 늘어나야 할 상황이 발생할때 자체 샤딩 솔류션인 클러스터를 사용하면 수평 확장이 굉장히 간단해 진다는 장점이 존재한다.

## 캐싱 전략

레디스를 캐시로 사용할 때 레디스를 어떻게 배치할 것인지에 다라 서비스의 성능에 큰 영향을 끼칠 수 있다.
캐싱 전략은 캐싱되는 데이터의 유형과 데이ㅓ에 대한 엑세스 패턴에 다라 다르기 대문에 서비스에 맞는 적절한 캐싱 전략을 선택하는 것이 중요하다.

#### 읽기 전략 - look aside

애플리케이션에서 데이터를 읽어갈 때 주로 사용하는 look aside 전략은 레디스를 캐시로 사용할 때 가장 일반적으로 배치하는 방법이다.

애플리케이션이 찾고자 하는 데이터를 먼저 캐시에 존재하는지 확인한 후 캐시에 데이터가 존재하면 캐시에서 데이터를 읽어온다 이를 캐시 히트라 한다.

찾고자하는 데이터가 없을때에는 캐시 미스가 발생하며 직접 데이터 베이스에서 찾고자 하는 데이터를 가져온다.

그 다음 애플리케이션은 그 데이터를 다시 캐시에 저장한다.

look aside 구조의 장점은 레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생하더라도 바로 서비스 장애로 이어지지 않고 데이터베이스에서 데이터를 가지고 올 수 있다는것. 하지만 기존에 애플리케이션에서 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많은 부하를 발생시키고 이로 인해 원본 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 등의 이슈가 발생해 애플리케이션 성능에 영향을 미칠 수 있음.

찾고자 하는 데이터가 레디스에 없을때에만 레디스에 데이터가 저장되기 때문에 이와 같은 구조를 lazy loading이라고도 부른다.

만약 기존에 사용 중인 서비스에 처음 레디스를 투입하거나 데이터베이스ㅔ만 새로운 데이터를 저장한다면 애플리케이션은 데이터를 찾기 위해 레디스에 매번 먼저 접근할 것이고 그때마다 캐시 미스가 일어나 데이터베이스와 레디스에 재접근하는 과정을 통해 지연이 초래돼 성능에 영향을 미칠 수 있다.

따라서 이럴 떄에는 미리 데이터베이스에 캐시로 데이터를 밀어넣어주는 작업을 하기도 하는데 이를 캐시 워밍이라고도 한다.

#### 쓰기 전략과 캐시의 일관성

캐시는 데이터 베이스에 저장돼 있는 데이터를 단순히 복사한 값이다.

따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수다

만약 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않는다면 데이터 간의 불일치가 일어난다. 이를 캐시 불일치(cache inconsistency)라고 한다.

이 경우 잘못된 값을 반환하는 경우가 생길 수 있다.

캐시를 이용한 쓰기 전략은 대표적으로 세 가지가 있다.

1) write through
	- 이 방식은 데이터베이스에 업데이트할 때마다 매번 캐시에도데이터를 함께 업데이트시키는 방식으로 캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만 데이터는 매번 2개의 저장소에 저장돼어야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.
	- 앞에서 언급햇듯 캐시는 다시 사용될 만한 데이터가 저장되는 것이 좋다. 하지만 이 방식의 경우 다시 사용되지 않을 데이터일 수도 있는데 무조건 캐시에도 저장되기 때문에 일종의 리소스 낭비가 발생할 수있다. 따라서 이 방식을 사용할 경우 데이터를 저장할 때 만료 시간을 사용할 것을 권장한다.
2) cache invalidation
	- 이 방식은 데이터베이스에 값을 업데이트 할 대마다 캐시에서는 데이터를 삭제하는 전략이다. 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 대문에 앞선 write through의 단점을 보완한 방법이다.
3) write behind(write back)
	- 만약 쓰기가 빈번하게 발생하는 서비스라면 wrtie behind 방식을 고려해 볼 수 있다. 데이터베이스의 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 유발해 성능 저하가 발생할 수 있다. 따라서 먼저 데이터를 빠르게 접근할 수 잇는 캐시에서 업데이트한 뒤 이후에 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트 하는 것이다.
	- 예를 들어 좋아요나 조회수 같은 것처럼 정확한 데이터가 아니어도 되는 경우 레디스에 저장해 둔뒤 데이터베이스에 업데이트하면 성능 향상에 도음을 준다. 단 캐시에 문제가 생겨 데이터가 날라간 경우 데이터가 날라갈 수 잇다는 위험성이 있음을 감수해야 한다.


