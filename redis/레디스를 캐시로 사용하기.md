어떤 상황에서 캐시를 사용해야 하는지 레디스를 캐시로 잘 사용하는 방법과 주의해야 할점까지 짚어보고 캐시와 비슷하면서도 다른 세션 스토어에 대해 함께 보자.

# 레디스와 캐시

## 캐시란?

데이ㅓ의 원본보다 더 빠르고 효율적으로 엑세스할 수 있는 임시 데이터 저장소를 의미한다. 사용자가 동일한 정보를 반복적으로 액세스할 때 원본이 아니라 캐시에서 데이터를 가지고 옴으로써 리소스를 줄인다.

캐시를 도입했을 때 성능을 효과적으로 개선할 수 있다.
- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야한다.
- 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
- 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
- 캐시에 저장된 데이터는 자주 검색되는 데이터다.
위의 조건들을 만족시키는 이상적인 캐시는 애플리케이션이 직면하게 되는 많은 문제점을 해결할 수 있다.

대기 시간 단축, 원본 데이터 저장소에 대한 커넥션 줄이기, CPU와 메모리 등의 리소스를 줄일수있으며 같은 값을 도출하기 위해 계속 같은 계산을 할 필요가 없으므로 리소스를 최적화시킬 수 있게 된다.

## 캐시로서의 레디스

레디스는 사용이 간단하다. 단순하게 키-값 형태로 저장되므로 데이터를 저장하고 반환하는 것이 굉장히 간단하며 자체적으로 다양한 자료 구조를 제공하기 때문에 애플리케이션에서 사용하던 list, hash 등의 자료 구조를 변환하는 과정 없이 레디스에 바로 저장할 수 있다.

또한 레디스는 인메모리 데이터 저장소이기에 데이터를 검색하고 반환하는 것이 상당히 빠르다는 특징을 가진다.

레디스는 자체적으로 고가용성 기능을 가지고 있는 솔루션이라는 점도 큰 장점이다. 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시키기 때문에 운영자 개입 없이 캐시는 정상으로 유지될 수 있어 가용성이 높아진다.

레디스의 클러스터를 사용하면 캐시의 스케일 아웃또한 쉽게 처리할 수 있어 서비스의 규모에 따라 캐시 자체의 규모도 늘어나야 할 상황이 발생할때 자체 샤딩 솔류션인 클러스터를 사용하면 수평 확장이 굉장히 간단해 진다는 장점이 존재한다.

## 캐싱 전략

레디스를 캐시로 사용할 때 레디스를 어떻게 배치할 것인지에 다라 서비스의 성능에 큰 영향을 끼칠 수 있다.
캐싱 전략은 캐싱되는 데이터의 유형과 데이ㅓ에 대한 엑세스 패턴에 다라 다르기 대문에 서비스에 맞는 적절한 캐싱 전략을 선택하는 것이 중요하다.

#### 읽기 전략 - look aside

애플리케이션에서 데이터를 읽어갈 때 주로 사용하는 look aside 전략은 레디스를 캐시로 사용할 때 가장 일반적으로 배치하는 방법이다.

애플리케이션이 찾고자 하는 데이터를 먼저 캐시에 존재하는지 확인한 후 캐시에 데이터가 존재하면 캐시에서 데이터를 읽어온다 이를 캐시 히트라 한다.

찾고자하는 데이터가 없을때에는 캐시 미스가 발생하며 직접 데이터 베이스에서 찾고자 하는 데이터를 가져온다.

그 다음 애플리케이션은 그 데이터를 다시 캐시에 저장한다.

look aside 구조의 장점은 레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생하더라도 바로 서비스 장애로 이어지지 않고 데이터베이스에서 데이터를 가지고 올 수 있다는것. 하지만 기존에 애플리케이션에서 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많은 부하를 발생시키고 이로 인해 원본 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 등의 이슈가 발생해 애플리케이션 성능에 영향을 미칠 수 있음.

찾고자 하는 데이터가 레디스에 없을때에만 레디스에 데이터가 저장되기 때문에 이와 같은 구조를 lazy loading이라고도 부른다.

만약 기존에 사용 중인 서비스에 처음 레디스를 투입하거나 데이터베이스ㅔ만 새로운 데이터를 저장한다면 애플리케이션은 데이터를 찾기 위해 레디스에 매번 먼저 접근할 것이고 그때마다 캐시 미스가 일어나 데이터베이스와 레디스에 재접근하는 과정을 통해 지연이 초래돼 성능에 영향을 미칠 수 있다.

따라서 이럴 떄에는 미리 데이터베이스에 캐시로 데이터를 밀어넣어주는 작업을 하기도 하는데 이를 캐시 워밍이라고도 한다.

#### 쓰기 전략과 캐시의 일관성

캐시는 데이터 베이스에 저장돼 있는 데이터를 단순히 복사한 값이다.

따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수다

만약 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않는다면 데이터 간의 불일치가 일어난다. 이를 캐시 불일치(cache inconsistency)라고 한다.

이 경우 잘못된 값을 반환하는 경우가 생길 수 있다.

캐시를 이용한 쓰기 전략은 대표적으로 세 가지가 있다.

1) write through
	- 이 방식은 데이터베이스에 업데이트할 때마다 매번 캐시에도데이터를 함께 업데이트시키는 방식으로 캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만 데이터는 매번 2개의 저장소에 저장돼어야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.
	- 앞에서 언급햇듯 캐시는 다시 사용될 만한 데이터가 저장되는 것이 좋다. 하지만 이 방식의 경우 다시 사용되지 않을 데이터일 수도 있는데 무조건 캐시에도 저장되기 때문에 일종의 리소스 낭비가 발생할 수있다. 따라서 이 방식을 사용할 경우 데이터를 저장할 때 만료 시간을 사용할 것을 권장한다.
2) cache invalidation
	- 이 방식은 데이터베이스에 값을 업데이트 할 대마다 캐시에서는 데이터를 삭제하는 전략이다. 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 대문에 앞선 write through의 단점을 보완한 방법이다.
3) write behind(write back)
	- 만약 쓰기가 빈번하게 발생하는 서비스라면 wrtie behind 방식을 고려해 볼 수 있다. 데이터베이스의 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 유발해 성능 저하가 발생할 수 있다. 따라서 먼저 데이터를 빠르게 접근할 수 잇는 캐시에서 업데이트한 뒤 이후에 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트 하는 것이다.
	- 예를 들어 좋아요나 조회수 같은 것처럼 정확한 데이터가 아니어도 되는 경우 레디스에 저장해 둔뒤 데이터베이스에 업데이트하면 성능 향상에 도음을 준다. 단 캐시에 문제가 생겨 데이터가 날라간 경우 데이터가 날라갈 수 잇다는 위험성이 있음을 감수해야 한다.

## 캐시에서의 데이터 흐름

기본적으로 캐시는 데이터 스토어가 갖고있는 데이터 중 사용자가 자주 사용할 만한 데이터를 갖고와서 임시로 저장하는 저장소다.

데이터 스토어보다 적은 양을 보관하는 데이터베이스의 서브셋이다.

레디스는 모든 데이터를 메모리에 저장하기에 서버의 스토리지보다 훨씬 적은 양을 보관할 수 밖에없다.

그렇기에 캐시가 가득 차지 않게 일정 양의 데이터를 유지해야 하며 계속 새로운 데이터가 저장되고 기존 데이터는 삭제될 수 있도록 관리돼야 한다.

따라서 캐시로 레디스를 사용할 때에는 데이터를 저장함과 동시에 적절한 시간의 TTL 값을 지정하는 것이 좋다.
`TTL - Time To Live`

#### 만료 시간
데이터가 얼마나 오래 저장될 것인지를 나타내는 설정 시간이다.
만료시간을 설정하면 레디스에서 자동으로 삭제되고 이를 통해 레디스에서 임시 데이터를 처리하거나 캐시 데이터를 유지하고 관리 할 수 있다. 키 만료 시간을 설정하면 데이터의 수명을 관리하고 메모리 공간을 효율적으로 사용하는데 도움을 준다.

레디스에서 키가 만료됐다고 해도 바로 메모리에서 삭제되는 것은 아니다. 키는 passvie 방식과 active 방식 두가지로 삭제 된다.

- passive - 클라이언트가 키에 접근하고자 할 때 키가 만료됐다면 메모리에서 수동적으로 삭제한다. 사용자가 접근할 때만 수동적으로 삭제되기 떄문에 이를 passive 방식의 만료라 한다.
- actvice - TTL 값이 있는 키 중 20개를 랜덤하게 뽑아낸뒤 만료된 키 를 모두 메모리에서 삭제한다. 만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고 아니라면 뽑은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행한다.

#### 메모리 관리와 maxmemory-policy 설정
메모리는 제한적이기 때문에 모든 키에 만료시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득 차는 상황이 발생할 수 있다. 메모리 용량을 초과하는 양의 데이터가 저장되면 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정한다.

이 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemory-policy 설정값을 사용해 메모리를 관리한다.

### Noeviction
기본값은 noeviction이다. 데이터가 가득 차더라도 임으로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정.
하지만 데이터를 저장하지 못해 에러가 발생할 수 있기에 레디스를 캐시로 사용할 때 권장하지 않는 설정값이다.

#### LRU eviction - 최근에 사용되지않은
LRU(Least-Recently Used) eviction은 레디스에 데이터가 가득 찼을때 가장 최근에 사용되지않은 데이터부터 삭제하는 정책이다. 최근에 엑세스되지 않은 데이터는 나중에도 엑세스될 가능성이 낮을 것이라는 가정을 전제한다. 효율적인 메모리 관리법이다.

LRU는 두가지 알고리즘이 있다.

- volatile-lru - 만료 시간이 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제한다. 장애를 유발할 가능성이 존재한다.
- allkeys-LRU - 레디스를 캐시로 사용할 경우 잘모르겠다면 allkeys-LRU를 권장한다. 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제하기 때문에 적어도 메모리가 꽉 찼을 때 장애가 발생할 상황은 방지할 수 있따.

#### LFU eviction - 자주 사용되지않은
LFU(Least-Frequently Used) evcition은 레디스에 데이터가 가득 찼을 때 가장 자주 사용되지 않는 데이터 부터 삭제하는 정책이다. 나중에도 엑세스될 가능성이 낮을 것이라는 가정을 전제로 한다.

특정 케이스에서 LRU보다 LFU가 효율적일 수 있다.

LFU또한 두가지 알고리즘이 있다.

- volatile-lfu - 만료 시간이 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제한다. 장애를 유발할 가능성이 존재한다.
- allkeys-lfu - 모든 키에 대해 LFU 알고리즘을 이용해 데이터를 삭제한다.

#### RANDOM eviction
레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다. 알고리즘을 사용하지 않기 떄문에 삭제될 키 값을 계산하지 않아도 되기에 레디스의 부하를 줄일 수 있다. 하지만 랜덤으로 삭제하기 때문에 나중에 사용할 데이터를 삭제할 수도 있다. 이럴 경우 다시 데이터를 넣어줘야하기에 불필요함을 유발할 수 있다. 권장하지 않는다.

#### volatile-ttl
volatile-ttl 방식은 만료 시간이 가장 작은 키를 삭제 한다. 즉 삭제 예정이 얼마 남지 않은 키를 추출해 미리 삭제하는 것이다. 만료시간을 비교하지 않아도 돼 간단하게 키를 찾아 낼 수 있다.

### 캐시 스탬피드 현상
대규모 트래픽 환경에서 만료 시간을 어떻게 설정하느냐에 따라 캐시 스탬피드와 같은 예상치 못한 문제 상황이 발생할 수 있다.

여러개의 애플리케이션에서 look aside 방식으로 레디스를 사용할 때 레디스에서 데이터를 찾을때 없을 경우 여러개의 애플리케이션에서 데이터베이스에 접근해 읽어와 다시 저장하기에 레디스에 부하를 준다. 중복 읽기와 중복 쓰기가 발생한다.

애플리케이션 에서 동시에 데이터베이스에 접근해 무거운 쿼리를 실행하는 중복 읽기 작업은 데이터베이스에 부하를주고 이는 곧 서비스 이슈로 이어질 수 있다.

이런 현상은 계단식 실패라고도 부른다.

이를 줄이기 위한 방법으로는 적절한 만료 시간 설정과 선 계산, PER 알고리즘이 있다.

#### 적절한 만료 시간 설정
만료시간을 너무 짧지 않게 설정하는 것이다. 여러 애플리케이션에서 접근해야하는 데이터의 경우에 데이터 저장 시점부터 만료 시간을 충분히 길게 설정해 주는것이 좋다.

#### 선 계산
만료시간이 끝나기 전에 먼거 계산을 하여 데이터베이스에서 새로운 데이터를 가지고와 레디스에 저장한다.

#### PER 알고리즘

