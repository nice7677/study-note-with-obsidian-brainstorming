메시지 브로커는 크게 **메시징 큐**와 **이벤트 스트림**이라는 두 가지 형태로 나눌 수 있다.

- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생산자(Producer), 데이터를 수신하는 쪽을 소비자(Consumer)로 지칭한다. 
- 이벤트 스트림에서는 데이터를 생성하는 쪽을 발행자(Publisher), 데이터를 조회하는 쪽을 구독자(Subscriber)로 지칭한다.

메시징 큐와 이벤트 스트림은 크게 두 가지 차이점을 가지고 있다.

## 방향성

### 메세징 큐

생산자는 소비자의 큐로 직접 데이터를 푸시 한다.
만약 소비자가 2개라면 2개의 서비스에 각각 메시지를 푸시 해야 하는 것이다.

### 이벤트 스트림

특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 메시지를 풀(pull)해 갈 수 있기 때문에 메시지를 복제해서 저장하지 않아도 된다.

## 데이터의 영속성

### 메시징 큐

소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다.
그렇기 때문에 메시지를 보내는 도중 새로운 소비자를 추가할때 메시징 큐를 이용한다면 소비자는 새롭게 추가된 이후의 이벤트만 확인할 수 있다.
따라서 메시징 큐는 1:1 상황에서 한 서비스가 다른 서비스에게 동작을 지시 할 때 유용하게 사용된다.

### 이벤트 스트림

구독자가 읽어간 데이터는 바로 삭제되지 않고 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다.
스트림 방식은 메시징 큐와 다르게 메시지를 생산할 때 구독자를 지정하지 않고 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스토리를 볼 수 있다.
따라서 스트림은 N:N 다대다 상황에서 유리하다.
