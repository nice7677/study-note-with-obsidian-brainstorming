메시지 브로커는 크게 **메시징 큐**와 **이벤트 스트림**이라는 두 가지 형태로 나눌 수 있다.

- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생산자(Producer), 데이터를 수신하는 쪽을 소비자(Consumer)로 지칭한다. 
- 이벤트 스트림에서는 데이터를 생성하는 쪽을 발행자(Publisher), 데이터를 조회하는 쪽을 구독자(Subscriber)로 지칭한다.

메시징 큐와 이벤트 스트림은 크게 두 가지 차이점을 가지고 있다.

## 방향성

### 메세징 큐

생산자는 소비자의 큐로 직접 데이터를 푸시 한다.
만약 소비자가 2개라면 2개의 서비스에 각각 메시지를 푸시 해야 하는 것이다.

### 이벤트 스트림

특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 메시지를 풀(pull)해 갈 수 있기 때문에 메시지를 복제해서 저장하지 않아도 된다.

## 데이터의 영속성

### 메시징 큐

소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다.
그렇기 때문에 메시지를 보내는 도중 새로운 소비자를 추가할때 메시징 큐를 이용한다면 소비자는 새롭게 추가된 이후의 이벤트만 확인할 수 있다.
따라서 메시징 큐는 1:1 상황에서 한 서비스가 다른 서비스에게 동작을 지시 할 때 유용하게 사용된다.

### 이벤트 스트림

구독자가 읽어간 데이터는 바로 삭제되지 않고 저장소의 설정에 따라 특정 기간 동안 저장될 수 있다.
스트림 방식은 메시징 큐와 다르게 메시지를 생산할 때 구독자를 지정하지 않고 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스토리를 볼 수 있다.
따라서 스트림은 N:N 다대다 상황에서 유리하다.

### 레디스를 메시지 브로커로 사용하기

레디스에서 제공하는 pub/sub을 사용하면 빠르고 간단한 방식으로 메시지를 전달할 수 있는 메시지 브로커를 구현 할 수 있다.
발행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비할 수 있다. 레디스의 pub/sub에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가지며 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다. 따라서 완벽하게 메시지가 전달돼야 하는 상황에는 적합하지 않을 수 있다.

#### list 자료 구조

list 자료 구조는 메시징 큐로 사용하지게 알맞다. list의 데이터는 푸시와 팝이 가능하며 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다 list에 새로운 데이터가 들어오면 읽어갈 수 있는 **블로킹 기능**을 사용할 수도 있다.

#### stream

stream을 사용하면 레디스를 완벽한 스트림 플랫폼으로 사용할 수 있다. 카프카를 본따 만들어 데이터는 계속 추가되는 방식으로 저장된다.(append-only) 소비자와 소비자 그룹이라는 개념을 이용하면 카프카에서와 비슷하게 데이터의 분산 처리를 구현할 수 있다. stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수도 있으며, 자장돼 있는 데이터를 시간대별로 검색하는 것도 가능하다.

## 레디스의 pub/sub

레디스는 아주 가벼운 pub/sub을 제공한다.
레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다. 발행자는 특정 채널에 메세지를 보낼 수 있으며, 구독자는 특정 채널을 리스닝하다가 메시지를 읽어갈 수 있다.

레디스에서 pub/sub은 매우 가볍기 때문에 최소한의 메시지 전달 기능만 제공한다. 발생자는 메시지를 채널로 보낼 수 있을 뿐, 어떤 구독자가 메시지를 읽어가는지 정상적으로 모든 구독자에게 메시지가 전달됐는지 확인할 수 없다. 구독자 또한 메시지를 발을 수 있지만 해당 메시지가 언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.

한 번 전파된 데이터는 레디스에 저장되지 않으며 **메시지의 통로 역할**만 한다. 그렇기에 정합성이 중요한 데이터를 전달하기에는 적합하지 않을 수 있다.

#### 메시지 publish하기

- PUBLISH - 데이터를 전파 할 수 있다.
```
PUBLISH hello world
(integer) 1
```

이렇게하면 hello라는 채널을 수신하고 있는 모든 서버들에 world라는 메시지가 전파된다. 전파 후 리턴은 구독자 수가 반환된다.

#### 메시지 구독하기

- SUBSCRIBE - 특정 채널을 구독할 수 있다.
```SUBSCRIBE event1 event2
Reading message... (press ~~)
1) "subscirbe"
2) "event1"
3) (integer) 1
1) "subscribe"
2) "event2"
3) (integer) 2
```

이렇게하면 동시에 event1과 event2를 구독하기 시작한다. 클라이언트가 구독자로 동작할 때에는 새로운 채널을 구독할 수 있지만 pub/sub과 관련되지 않은 다른 커맨드를 수행할 수 없다.

##### 구독자가 수행할 수 있는 커맨드
- SUBSCRIBE
- SSUBSCRIBE
- SUNSUBSCRIBE
- PSUBSCRIBE
- UNSUBSCRIBE
- PUNSUBSCRIBE
- PING
- RESET
- QUIT

PSUBSCRIBE 커맨드를 쓰면 일치하는 패턴에 해당 채널을 한 번에 구독 가능하다.
```
PSUBSCRIBE mail-*
Reading message...
1) "psubscribe"
2) "mail-*"
3) (integer) 1
```

mail- 로 시작하는 모든 채널에 전파된 메세지를 수신할 수 있다. SUBSCRIBE와 마찬가지로 동시에 여러 문자열을 구독하는 것도 가능하다. 이때 메시지는 message가 아닌 pmessage 타입으로 전달되 SUBSCRIBE을 사용해 메시지를 구독하는 방식과 구분된다.

## 클러스터 구조에서의 pub/sub

레디스 클러스터에서 pub/sub을 사용하면 메시지가 발행될때 해당 메시지는 클러스터에 속한 **모든 노드에 자동으로 전달된다.** 따라서 레디스 클러스트 아무 노드에 연결해 SUBSCRIBE을 사용하면 데이터를 수신 할 수 있다.
하지만 이 방법은 모든 클러스터에 메세지가 전파되기에 클러스터의 주요 목적을 고려한다면 비효율적인 방식이다. 모든 노드에 복제되는 방식은 클러스터 환경의 핵심 목표와는 부합하지 않으며 이로 인해 **불필요한 리소스 사용과 네트워크 부하가 발생할 수 있다.**

#### sharded pub/sub

위의 비효율을 해결하기 위해 레디스 7.0에서는 sharded pub/sub 기능이 도입됐다.
sharded pub/sub 환경에서는 각 채널은 **슬롯**에 매핑된다. 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파한다.

sharded pub/sub을 이용하면 클러스터 구조에서 pub/sub되는 메시지는 모든 노드로 전파되지 않기 때문에 불필요한 복제를 줄여 자원을 절약할 수 있다는 장점이 있다.
